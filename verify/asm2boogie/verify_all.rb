require 'optparse'
require 'set'

Archs = { "arm-v8" => ["armv8", "atomic.s"], "risc-v" => ["risc", "atomic_riscv.s"] }
options = {}
options[:generate] = true;
options[:which] = "atomics_list_full.txt"
options[:where] = "out"
options[:archs] = Archs.keys
options[:extract] = true
options[:phases] = Set.new [ 1, 2 ]

OptionParser.new do |opts|
  opts.banner = "Usage: verify_all.rb [options]"

  opts.on("-s", "--specified=PATH/TO/ATOMICS_LIST|fun1,...,funk:prop1,...,propn", "verify only specified functions & properties") do |v|
    options[:generate] = false

    if /\w+(,\w+)*:\w+(,\w+)*/ =~ v
      funcs, ops = v.split(":").map { |foo| foo.split(",") }
      options[:limit] = { :functions => funcs, :properties => ops } 
      puts "only verifying #{funcs} : #{ops}" 
    else
      options[:which] = v
      options[:which_failed] = v
    end
  end

  
  opts.on("-a", "--architectures=ARCH1,...,ARCHn", "only verify specified architectures") do |v|
    options[:archs] = v.split.map { |s| s.strip }
  end

  opts.on("-o", "--output=PATH/TO/OUT", "output folder of templates") do |v|
    options[:where] = v
  end

  opts.on("-v", "--verify-only", "only do verification") do |v|
    options[:extract] = false
  end

  opts.on("-p", "--phases=PHASE1,...,PHASEN", "Only do these verification phase") do |v|
    options[:phases] = Set.new (v.split.map { |s| s.to_i })
  end
  opts.on("-h", "--help", "Prints this help") do
    puts opts
    exit
  end
end.parse!


def verify(arch, out, atomic, templates)
  (library, asm_file) = Archs[arch]
  `boogie /proverOpt:SOLVER=z3 /proverOpt:LOG_FILE=#{out}/#{atomic}/prover.in ../boogie/auxiliary.bpl ../boogie_#{library}/library.bpl #{templates.map{ |template| "#{out}/#{atomic}/#{template}.bpl" }.join " "}`.strip
end



if options[:generate]
    `ruby gen_atomic_list.rb > #{options[:which]}`
end


def compile(asm_file, library, functions_path, out, arch, unroll = false)
  `cargo run -- --input data/#{asm_file} --functions #{functions_path} --templates ../boogie/templates/ --directory #{out}/#{arch} --arch #{arch} #{ unroll ? "--unroll" : nil }`
end

retry_out = "#{options[:where]}_retry"
if options[:extract]
    options[:archs].each { |arch|
        (library, asm_file) = Archs[arch]
        compile(asm_file, library, options[:which], options[:where], arch)
    }
end

def drop_extension(path)
  File.basename(path, File.extname(path))
end


def verify_all(archs, out, which, limit, phase)

  if which
    archs.each { |arch|
        (library, asm_file) = Archs[arch]
        compile(asm_file, library, which, out, arch, unroll=phase==2)
    }
  end

  $results = {}
  archs.each { |arch|   

    (library, asm_file) = Archs[arch]
    if ! limit 
      match = File.read("../boogie_#{library}/library.bpl").match(/procedure\s+execute.*?(?<modifies>modifies.*?);/m)
      modifies = match[:modifies]
      library_correctness = File.new("../boogie_#{library}/correctness.bpl", "w")
      library_correctness << "/* This file is automatically generated. Do not modify. */"
      library_correctness << File.read("../boogie/correctness.bpl").sub("#modifies", modifies)
      library_correctness.close

      puts "======================="
      puts "verifying ISA [#{arch}] ( ../boogie_#{library}/correctness.bpl )"
      puts `boogie /proverOpt:SOLVER=z3 ../boogie/auxiliary.bpl ../boogie_#{library}/library.bpl ../boogie_#{library}/correctness.bpl`.strip
      puts "======================="
    end

    base_path = File.join(out, arch)
    $results[arch] = Parallel.map(Dir::children(base_path), in_processes: 10) { |atomic|
      if ! limit || limit[:functions].include?(atomic)
        templates = Dir::children(File.join(base_path,atomic))
          .map { |template| drop_extension(template) }
          .filter { |template| template != "registers" && template != "prover" && (! limit || limit[:properties].include?(template)) }
        
        next if templates.empty?

        puts "[begin #{arch}/#{atomic} #{templates}]"

        lines = ["=======================", 
        "verifying #{atomic} on #{arch}",
        ]
        local_results = []

    
        lines << "#{templates}:"
        out = verify(arch, base_path, atomic, templates + [ "registers" ])
        
        lines << out
        pass = /0 errors/ =~ out
        local_results << [atomic, pass]
          
        if ! pass
          lines << "to rerun this test:\n\n    ruby #{__FILE__} -a #{arch} -s #{atomic}:#{templates.join ","} -v -p #{phase}\n"
        end

        lines << "\n"

        puts lines
        local_results
      end
    }.flatten 1
  }
end


require 'pp'
require 'parallel'
begin
  if options[:phases].include? 1
    verify_all(options[:archs], options[:extract] && options[:which], options[:where], options[:limit], 1)
    puts ""
    puts "finished simple verification"
    puts ""
  end
      
ensure
  failed_file = "FAILED_#{options[:which]}"
  options[:which_failed] ||= failed_file

  if $results && $results.any? { |result| result.any? { |(_,pass)| ! pass }} 
    if /FAILED_/ =~ options[:which]
      puts "to rerun:\n\n    ruby #{__FILE__} -a #{options[:archs].join(",")} -s #{options[:which]}"
    else

      File.open(failed_file, "w") do |f|
        f.write($results.map { |_arch, result| result.filter { |(_,pass)| ! pass }.map {|(atomic,_)| atomic} }.flatten.join("\n"))
      end
      
      puts ""
      
      puts "to rerun all failed atomics:\n\n    ruby #{__FILE__} -a #{options[:archs].join(",")} -s #{failed_file}"

      if options[:phases].include? 2
        puts ""
        puts ""
        puts ""
        puts "========================================================="
        puts "*                                                       *"
        puts "*    retrying failed atomics with heavy verification    *"
        puts "*                                                       *"
        puts "========================================================="
        puts ""
        puts ""
        puts ""
        
        verify_all(options[:archs], retry_out, options[:extract] && failed_file, options[:limit], 2)

        puts ""
        puts "finished heavy verification"
      end
    end
  elsif (options[:phases].include? 2)
    verify_all(options[:archs], retry_out, options[:extract] && options[:which_failed], options[:limit], 2)


  end

  if ! $results
    puts "no tests run"
  elsif $results.all? { |_arch, result| result.all? { |(_,pass)| pass }} 
    puts "no failures found"
  end
end